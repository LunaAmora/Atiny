use std::str::FromStr;

use atiny_tree::r#abstract::*;
use atiny_location::*;

grammar;

Loc<T>: Located<T> = {
    <s: @L> <data: T> <e: @R> => Located { data, location: ByteRange(Byte(s), Byte(e)) }
}

//         (Vec,Trailing)
Sep<U, T>: (Vec<T>, bool) = {
    <mut v:(<T> U)*> <e:T?> => match e {
        Some(e) => {
            v.push(e);
            (v, false)
        }
        None => (v, true)
    }
};

// O: From<AtomKind<O>>
AtomItem<I, O> : O = {
    "_" => AtomKind::Wildcard.into(),
    Num => AtomKind::Number(<>).into(),
    Id  => AtomKind::Identifier(<>).into(),
    "(" <mut sep:Sep<",", I>> ")" => {
        let (mut vec, trailing) = sep;

        match vec.len() {
            0 => AtomKind::unit().into(),
            1 if !trailing => vec.pop().unwrap().data,
            _ => AtomKind::Tuple(vec).into(),
        }
    },
}

// For expressions

AtomExpr: Expr = Loc<AtomItem<Expr, ExprItem>>;

CallItem: ExprKind = <t:Call> <a:AtomExpr> => ExprKind::Application(Box::new(t), Box::new(a));

Call: Expr = {
    Loc<CallItem>,
    AtomExpr
};

ExprItem: ExprKind = {
    "|" <t:LowerId> "|" <s:Expr>                   => ExprKind::Abstraction(t, Box::new(s)),
    "let" <t:LowerId> "=" <e:Expr> ";" <next:Expr> => ExprKind::Let(t, Box::new(e), Box::new(next)),
    "match" <pat:Expr> "{" <c:Clauses> "}"         => ExprKind::Match(Box::new(pat), c),
    "if" "let" <Pattern> "=" <Expr>
        "{" <Expr> "}" "else" 
        "{" <Expr> "}"                             => ExprKind::if_let(<>),
    <f:Call> <t:TypeAnotation>                     => ExprKind::Annotation(Box::new(f), Box::new(t)),
    <t:Call> "#{" <fields:Fields> "}"              => ExprKind::RecordCreation(Box::new(t), fields),
    <f:AtomExpr> "." <name:LowerId>                => ExprKind::Field(Box::new(f), name),
};

Block: Expr = {
    "{" <Expr> "}",
    Loc<r"[{][\s]*[}]"> => <>.map(|_| ExprKind::Atom(AtomKind::unit()))
};

pub Expr: Expr = {
    Loc<ExprItem>,
    Block,
    Call
};

AtomPattern: Pattern = Loc<AtomItem<Pattern, PatternItem>>;

PatternItem: PatternKind = UpperId AtomPattern+ => PatternKind::Constructor(<>);

Pattern: Pattern = {
    Loc<PatternItem>,
    AtomPattern
};

Clause: Clause = <Pattern> "=>" <Expr> => Clause::new(<>);

Clauses: Vec<Clause> = Sep<",", Clause> => <>.0;

ExprField: ExprField = <name: LowerId> "=" <expr: Expr> => ExprField {<>};

Fields: Vec<ExprField> = Sep<",", ExprField> => <>.0;

// For Types

TypeAtomItem: TypeKind = {
    <name: Id> => TypeKind::Variable(VariableNode {<>}),
    "(" <mut sep:Sep<",", TypeNode>> ")" => {
        let (mut types, trailing) = sep;

        match types.len() {
            0 => TypeKind::unit(),
            1 if !trailing => types.pop().unwrap().data,
            _ => TypeKind::Tuple(TypeTupleNode { types }),
        }
    }
}

TypeAtom: TypeNode = Loc<TypeAtomItem>;

TypeCallItem: TypeKind = {
    <fun:UpperId> <args:TypeAtom+> => TypeKind::Application(TypeApplicationNode {<>}),
}

TypeCall: TypeNode = {
    Loc<TypeCallItem>,
    TypeAtom
};

TypeArrowItem: TypeKind = <TypeCall> "->" <TypeNode> => TypeKind::Arrow(ArrowNode::new(<>));

TypeArrow: TypeNode = {
    Loc<TypeArrowItem>,
    TypeCall
};

TypeKind: TypeKind = {
    "forall" <args: LowerId*> "." <body: TypeNode> => {
        TypeKind::Forall(ForallNode { args, body: Box::new(body) })
    }
}

TypeNode: TypeNode = {
    Loc<TypeKind>,
    TypeArrow
};

// Top level

Constructor: Constructor = "|" <name: UpperId> <types: TypeAtom*> => Constructor {<>};

Field: Field = <name: LowerId> ":" <ty: TypeNode> => Field {<>};

TypeDeclKind: TypeDeclKind = {
    Constructor+              => TypeDeclKind::Sum(<>),
    "{" <Sep<",", Field>> "}" => TypeDeclKind::Product(<>.0)
}

TypeDecl: TypeDecl = {
    "type" <name: UpperId> <params: LowerId*> "=" <constructors: TypeDeclKind> => TypeDecl {<>}
}

TypeAnotation: TypeNode = ":" <TypeNode>;

Param: (Pattern, TypeNode) = "(" <Pattern> <TypeAnotation> ")" => (<>);

FnDecl: FnDecl = "fn" <Loc<LowerId>> <Param*> <TypeAnotation?> <Block> => FnDecl::new(<>);

TopLevelKind: TopLevelKind = {
    FnDecl   => TopLevelKind::FnDecl(<>), 
    TypeDecl => TopLevelKind::TypeDecl(<>), 
}

TopLevel: TopLevel = Loc<TopLevelKind>;

pub Program: Vec<TopLevel> = TopLevel*;

Num: u64 = r"[0-9]+" => u64::from_str(<>).unwrap();

LowerId: String =  {
    r"[a-z]"               => <>.to_string(),
    r"[a-z_][a-zA-Z0-9_]+" => <>.to_string(),
}

UpperId: String = r"[A-Z][a-zA-Z0-9_]*" => <>.to_string();

Id: String = {
    LowerId,
    UpperId,
}
