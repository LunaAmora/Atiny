use std::str::FromStr;

use atiny_tree::r#abstract::*;
use atiny_location::*;

grammar;

Loc<T>: Located<T> = {
    <s: @L> <data: T> <e: @R> => Located { data, location: ByteRange(Byte(s), Byte(e)) }
}

Sep<U, T>: Vec<T> = {
    <mut v:(<T> U)*> <e:T?> => match e {
        Some(e) => {
            v.push(e);
            v
        }
        None => v
    }
};

// For expressions

ExprAtomItem: AtomKind<Expr> = {
    "_" => AtomKind::Wildcard,
    Num => AtomKind::Number(<>),
    Id  => AtomKind::Identifier(<>),
    "(" <mut vec:Sep<",", Expr>> ")" => {
        match vec.len() {
            0 => AtomKind::unit(),
            1 => AtomKind::Group(Box::new(vec.pop().unwrap())),
            _ => AtomKind::Tuple(vec),
        }
    },
}

AtomExpr: Expr = Loc<ExprAtomItem> => <>.map(|a| ExprKind::Atom(a));

CallItem: ExprKind = <t:Call> <a:AtomExpr> => ExprKind::Application(Box::new(t), Box::new(a));

Call: Expr = {
    Loc<CallItem>,
    AtomExpr
};

ExprItem: ExprKind = {
    "|" <t:LowerId> "|" <s:Expr>                   => ExprKind::Abstraction(t, Box::new(s)),
    "let" <t:LowerId> "=" <e:Expr> ";" <next:Expr> => ExprKind::Let(t, Box::new(e), Box::new(next)),
    "match" <pat:Expr> "{" <c:Clauses> "}"         => ExprKind::Match(Box::new(pat), c),
    "if" "let" <Pattern> "=" <Expr>
        "{" <Expr> "}" "else" 
        "{" <Expr> "}"                             => ExprKind::if_let(<>),
    <f:Call> <t:TypeAnotation>                     => ExprKind::Annotation(Box::new(f), Box::new(t)),
    <t:Call> "#{" <fields:Sep<",", ExprField>> "}" => ExprKind::RecordCreation(Box::new(t), fields),
    <f:AtomExpr> "." <name:LowerId>                => ExprKind::Field(Box::new(f), name),
};

Block: Expr = {
    "{" <Expr> "}",
    Loc<r"[{][\s]*[}]"> => <>.map(|_| ExprKind::Atom(AtomKind::unit()))
};

pub Expr: Expr = {
    Loc<ExprItem>,
    Block,
    Call
};

PatAtomItem: AtomKind<Pattern> = {
    "_" => AtomKind::Wildcard,
    Num => AtomKind::Number(<>),
    Id  => AtomKind::Identifier(<>),
    "(" <mut vec:Sep<",", Pattern>> ")" => {
        match vec.len() {
            0 => AtomKind::unit(),
            1 => AtomKind::Group(Box::new(vec.pop().unwrap())),
            _ => AtomKind::Tuple(vec),
        }
    },
}

AtomPat: Pattern = Loc<PatAtomItem> => <>.map(|p| PatternKind::Atom(p));

PatternItem: PatternKind = UpperId AtomPat+ => PatternKind::Constructor(<>);

Pattern: Pattern = {
    Loc<PatternItem>,
    AtomPat
};

Clause: Clause = <Pattern> "=>" <Expr> => Clause::new(<>);

Clauses = Sep<",", Clause>;

ExprField: ExprField = <name: LowerId> "=" <expr: Expr> => ExprField {<>};

// For Types

TypeAtomItem: TypeKind = {
    <name: Id> => TypeKind::Variable(VariableNode {<>}),
    "(" <mut types:Sep<",", TypeNode>> ")" => {
        match types.len() {
            0 => TypeKind::unit(),
            1 => types.pop().unwrap().data,
            _ => TypeKind::Tuple(TypeTupleNode { types }),
        }
    }
}

TypeAtom: TypeNode = Loc<TypeAtomItem>;

TypeCallItem: TypeKind = {
    <fun:UpperId> <args:TypeAtom+> => TypeKind::Application(TypeApplicationNode {<>}),
}

TypeCall: TypeNode = {
    Loc<TypeCallItem>,
    TypeAtom
};

TypeArrowItem: TypeKind = <TypeCall> "->" <TypeNode> => TypeKind::Arrow(ArrowNode::new(<>));

TypeArrow: TypeNode = {
    Loc<TypeArrowItem>,
    TypeCall
};

TypeKind: TypeKind = {
    "forall" <args: LowerId*> "." <body: TypeNode> => {
        TypeKind::Forall(ForallNode { args, body: Box::new(body) })
    }
}

TypeNode: TypeNode = {
    Loc<TypeKind>,
    TypeArrow
};

// Top level

Constructor: Constructor = "|" <name: UpperId> <types: TypeAtom*> => Constructor {<>};

Field: Field = <name: LowerId> ":" <ty: TypeNode> => Field {<>};

TypeDeclKind: TypeDeclKind = {
    Constructor+                      => TypeDeclKind::Sum(<>),
    "{" <fields: Sep<",", Field>> "}" => TypeDeclKind::Product(<>)
}

TypeDecl: TypeDecl = {
    "type" <name: UpperId> <params: LowerId*> "=" <constructors: TypeDeclKind> => TypeDecl {<>}
}

TypeAnotation: TypeNode = ":" <TypeNode>;

Param: (Pattern, TypeNode) = "(" <Pattern> <TypeAnotation> ")" => (<>);

FnDecl: FnDecl = "fn" <Loc<LowerId>> <Param*> <TypeAnotation?> <Block> => FnDecl::new(<>);

TopLevelKind: TopLevelKind = {
    FnDecl   => TopLevelKind::FnDecl(<>), 
    TypeDecl => TopLevelKind::TypeDecl(<>), 
}

TopLevel: TopLevel = Loc<TopLevelKind>;

pub Program: Vec<TopLevel> = TopLevel*;

Num: u64 = r"[0-9]+" => u64::from_str(<>).unwrap();

LowerId: String =  {
    r"[a-z]"               => <>.to_string(),
    r"[a-z_][a-zA-Z0-9_]+" => <>.to_string(),
}

UpperId: String = r"[A-Z][a-zA-Z0-9_]*" => <>.to_string();

Id: String = {
    LowerId,
    UpperId,
}
