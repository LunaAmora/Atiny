use std::str::FromStr;

use atiny_tree::r#abstract::*;
use atiny_location::*;

grammar;

Loc<T>: Located<T> = {
    <s: @L> <data: T> <e: @R> => Located { data, location: ByteRange(Byte(s), Byte(e)) }
}

Sep<U, T>: Vec<T> = {
    <mut v:(<T> U)*> <e:T?> => match e {
        Some(e) => {
            v.push(e);
            v
        }
        None => v
    }
};



// For expressions


ExprAtomItem: AtomKind<Expr> = {
    <n:Num>            => AtomKind::Number(n),
    <id: Id>           => AtomKind::Identifier(id),
    "(" <mut vec:Sep<",", Expr>> ")" => {
        match vec.len() {
            0 => AtomKind::Identifier("Unit".to_string()),
            1 => AtomKind::Group(Box::new(vec.pop().unwrap())),
            _ => AtomKind::Tuple(vec),
        }
    },
}

AtomExpr: Expr = {
    <a: Loc<ExprAtomItem>> => a.map(|a| ExprKind::Atom(a))
};

CallItem: ExprKind = {
    <t:Call> <a:AtomExpr> => ExprKind::Application(Box::new(t), Box::new(a)),
    <t:AtomExpr>          => t.data,
}

Call: Expr = Loc<CallItem>;

ExprItem: ExprKind = {
    "|" <t: Id> "|" <s:Expr>                     => ExprKind::Abstraction(t, Box::new(s)),
    "let" <t: Id> "=" <e:Expr> ";" <next:Expr>   => ExprKind::Let(t, Box::new(e), Box::new(next)),
    "match" <pat:Expr> "{" <c:Clauses> "}"       => ExprKind::Match(Box::new(pat), c),
    "if" "let" <pat:AtomPat> "=" <m:Expr>
        "{" <t:Expr> "}" "else"
        "{" <f:Expr> "}"                         => ExprKind::if_let(pat, m, t, f),
    "{" <t:Expr> "}"                             => t.data,
    <f:Call> ":" <t: TypeNode>                       => ExprKind::Annotation(Box::new(f), Box::new(t)),
    <f:Call>                                     => f.data,
};

pub Expr : Expr = Loc<ExprItem>;

PatAtomItem: AtomKind<Pattern> = {
    <n:Num>            => AtomKind::Number(n),
    <id: Id>           => AtomKind::Identifier(id),
    "(" <mut vec:Sep<",", Pattern>> ")" => {
        match vec.len() {
            0 => AtomKind::Identifier("Unit".to_string()),
            1 => AtomKind::Group(Box::new(vec.pop().unwrap())),
            _ => AtomKind::Tuple(vec),
        }
    },
}

AtomPat: Pattern = {
    <a: Loc<PatAtomItem>> => a.map(|a| PatternKind::Atom(a))
};

Clause: Clause = {
    <pat:Pattern> "=>" <e:Expr> => Clause::new(pat, e)
}

Clauses = Sep<",", Clause>;

PatternItem : PatternKind = {
    <pat:AtomPat>               => pat.data,
    <name: Id> <pats: AtomPat+> => PatternKind::Constructor(name, pats)
}

Pattern : Pattern = Loc<PatternItem>;

// For Types

TypeAtomItem : TypeKind = {
    <id: Id>                    => TypeKind::Variable(VariableNode { name: id }),
    "(" <mut types:Sep<",", TypeNode>> ")" => {
        match types.len() {
            0 => TypeKind::Variable(VariableNode {name : "Unit".to_string()}),
            1 => types.pop().unwrap().data,
            _ => TypeKind::Tuple(TypeTupleNode { types }),
        }
    }
}

TypeAtom : TypeNode = Loc<TypeAtomItem>;

TypeCallItem : TypeKind = {
    <fun: Id> <args: TypeAtom+> => TypeKind::Application(TypeApplicationNode { fun, args }),
    <t:TypeAtom>         => t.data,
}

TypeCall : TypeNode = Loc<TypeCallItem>;

TypeArrowItem : TypeKind = {
    <t:TypeCall> "->" <a:TypeNode> => TypeKind::Arrow(ArrowNode { left: Box::new(t), right: Box::new(a) }),
    <t:TypeCall>               => t.data,
}

TypeArrow : TypeNode = Loc<TypeArrowItem>;

TypeKind : TypeKind = {
    <t: TypeArrow> => t.data,
    "forall" <args: Id*> "." <body: TypeNode> => TypeKind::Forall(ForallNode { args, body: Box::new(body) }),
}

TypeNode : TypeNode = Loc<TypeKind>;

// Top level

Constructor : Constructor = {
    "|" <name: Id> <types: TypeAtom*> => Constructor { name, types } 
}

TypeDecl : TypeDecl = {
    "type" <name: Id> <params: Id*> "=" <constructors: Constructor*> => TypeDecl {
        name,
        params,
        constructors
    }
}

Param : (String, TypeNode) = {
    "(" <name: Id> ":" <typ: TypeNode> ")" => (name, typ)
}

FnDecl : FnDecl = {
    "fn" <name: Id> <params: Param*> ":" <ret: TypeNode> "{" <body: Expr> "}" => FnDecl {
        name,
        params,
        ret: Box::new(ret),
        body: Some(body)
    }
} 

TopLevelKind : TopLevelKind = {
    <FnDecl> => TopLevelKind::FnDecl(<>), 
    <TypeDecl> => TopLevelKind::TypeDecl(<>), 
}

TopLevel : TopLevel = Loc<TopLevelKind>;

pub Program : Vec<TopLevel> = {
    <TopLevel*> => <>
}

Num: u64 = <s:r"[0-9]+">                   => u64::from_str(s).unwrap();
Id: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string();
