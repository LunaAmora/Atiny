use std::str::FromStr;
use crate::syntax::*;

grammar;

Loc<T>: Syntax = {
    <s: @L> <data: T> <e: @R> => Syntax { data, location: ByteRange(Byte(s), Byte(e)) }
}

AtomItem: Item = {
    <n:Num>            => Item::Number(n),
    "true"             => Item::Boolean(true),
    "false"            => Item::Boolean(false),
    <id: Id>           => Item::Identifier(id),
    "(" <t:Syntax> ")" => t.data,
}

Atom: Syntax = Loc<AtomItem>;

CallItem: Item = {
    <t:Call> <a:Atom> => Item::Application(Box::new(t), Box::new(a)),
    <t:Atom>          => t.data,
}

Call: Syntax = Loc<CallItem>;

Clause: Clause = {
    <pat:Atom> "=>" <e:Syntax> => Clause::new(Pattern(pat), e)
}

Clauses = Comma<Clause>;

SyntaxItem: Item = {
    "|" <t: Id> "|" <s:Syntax>                     => Item::Abstraction(t, Box::new(s)),
    "let" <t: Id> "=" <e:Syntax> ";" <next:Syntax> => Item::Let(t, Box::new(e), Box::new(next)),
    "match" <pat:Syntax> "{" <c:Clauses> "}"       => Item::Match(Box::new(pat), c),
    "if" "let" <pat:Atom> "=" <m:Syntax> 
        "{" <t:Syntax> "}" "else" 
        "{" <f:Syntax> "}"                         => Item::if_let(pat, m, t, f),
    "{" <t:Syntax> "}"                             => t.data,
    <f:Call>                                       => f.data,
};

pub Syntax : Syntax = Loc<SyntaxItem>;

Num: u64 = <s:r"[0-9]+">                   => u64::from_str(s).unwrap();
Id: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string();

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
